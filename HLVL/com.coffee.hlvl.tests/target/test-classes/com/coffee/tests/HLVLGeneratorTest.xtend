/*
 * generated by Xtext 2.12.0
 */
package com.coffee.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import com.coffee.hlvl.Model
import com.coffee.hlvl.HlvlPackage
import com.coffee.generator.ParserFactory
import com.coffee.generator.Dialect
import com.coffee.generator.HlvlGenerator

/**
 * Class to test the correct parsing of HLVL
 * @author Angela Villota
 * @version HLVL V4
 * November 2018
 * 
 */
@RunWith(XtextRunner)
@InjectWith(HlvlInjectorProvider)
class HLVLGeneratorTest {
	@Inject
	ParseHelper<Model> parseHelper
	
	@Test
	def void getDialect() {
		val basicProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		relations:
		r1: common(A,B)
		'''

		//This verifies that the models is syntactically correct
		var model = parseHelper.parse(basicProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		var HlvlGenerator gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.BASIC_BOOL, gen.findDialect(model))
		
		val attProgram = 
		'''
		model empty
		elements:
		boolean A
		att boolean B
		relations:
		r1: common(A,B)
		'''

		//This verifies that the models is syntactically correct
		 model = parseHelper.parse(attProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.ATTRIBUTE, gen.findDialect(model))
		
		val multProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		relations:
		r1: decomposition(A, [B], [1,4])
		'''

		//This verifies that the models is syntactically correct
		 model = parseHelper.parse(multProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.MULTIPLICITY, gen.findDialect(model))
		
		val attMultProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		att integer C variants: 1..5
		relations:
		r1: decomposition(A, [B], [1,4])
		'''

		//This verifies that the models is syntactically correct
		 model = parseHelper.parse(attMultProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.MULTIPLICITY, gen.findDialect(model))
	}
	
	@Test
	def void boolParser() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		relations:
		r1: common(A,B)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var bool : A ;
		var bool : B ;
		% Variables and constraints from the variability relations definition
		constraint A == true ;
		constraint B == true ;
		% The solving parameters from the parameters files
		'''
		//Obtained code
		val parser= ParserFactory.getParser(Dialect.BASIC_BOOL, model.name);
		val actual= parser.parseModel(model)
		
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
	
	@Test
	def void complexBoolParser() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		boolean C
		boolean D
		boolean F
		boolean G
		relations:
		r1: common(A,B)
		r2: implies((A = B), [C, D])
		r3: mutex((C OR D), [F,G])
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var bool : A ;
		var bool : B ;
		var bool : C ;
		var bool : D ;
		var bool : F ;
		var bool : G ;
		% Variables and constraints from the variability relations definition
		constraint A == true ;
		constraint B == true ;
		constraint (A == B) -> C;
		constraint (A == B) -> D;
		constraint not((C \/ D) /\ F);
		constraint not((C \/ D) /\ G);
		% The solving parameters from the parameters files
		'''
		//Obtained code
		val parser= ParserFactory.getParser(Dialect.COMPLEX_BOOL, model.name);
		val actual= parser.parseModel(model)
		
		println(actual);
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
	
	@Test
	def void gplBasicBooleanTest() {
		val hlvlProgram = 
		'''
		model GPL
		elements:  
			boolean GPL 
			boolean Gtp 
			boolean directed
			boolean undirected
			boolean Weight
			boolean weighted
			boolean unweighted
			boolean Search
			boolean BFS
			boolean DFS
			boolean Algorithms
			boolean connected
			boolean stronglyc
			boolean cycle
			boolean mstprim
			boolean mstkruskal
			boolean shortest
		relations:
			R1: common(GPL)
			R2: decomposition(GPL,[Weight, Search], [0,1])
			R3: decomposition(GPL, [Gtp, Algorithms], [1,1])
			R3X: group(Gtp, [directed, undirected], [1,1])
			R4: group(Weight, [weighted, unweighted], [1,1])
			R5: group(Search, [BFS, DFS], [1,1])
			R6: group(Algorithms, [connected, stronglyc, cycle, mstprim, mstkruskal, shortest], [1,*])
			R7: implies(mstprim, unweighted)
			R8: mutex(stronglyc, shortest)
			R9: expression(undirected OR ~mstprim)
			R10: expression(directed OR ~shortest)
			R11: expression( ~mstprim OR ~mstkruskal )
		 	R12: expression( unweighted OR ~mstkruskal )
		 	R13: expression( undirected OR ~stronglyc )
		 	R14: expression( ~connected OR ~stronglyc )
		 	R15: expression( Search OR ~connected )
		 	R16: expression( undirected OR ~mstkruskal )
		 	R17: expression( ~mstkruskal OR ~shortest )
		 	R18: expression( DFS OR ~cycle )
		 	R19: expression( ~mstprim OR ~shortest)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		//testing the generator
		val HlvlGenerator gen = new HlvlGenerator
		
		val parser= ParserFactory.getParser(gen.findDialect(model), model.name);
		
		val actual= parser.parseModel(model)
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var bool : GPL ;
		var bool : Gtp ;
		var bool : directed ;
		var bool : undirected ;
		var bool : Weight ;
		var bool : weighted ;
		var bool : unweighted ;
		var bool : Search ;
		var bool : BFS ;
		var bool : DFS ;
		var bool : Algorithms ;
		var bool : connected ;
		var bool : stronglyc ;
		var bool : cycle ;
		var bool : mstprim ;
		var bool : mstkruskal ;
		var bool : shortest ;
		% Variables and constraints from the variability relations definition
		constraint GPL == true ;
		constraint Weight -> GPL ;
		constraint Search -> GPL ;
		constraint GPL <-> Gtp ;
		constraint GPL <-> Algorithms ;
		constraint directed <-> (not(undirected) /\ Gtp) ;
		constraint undirected <-> (not(directed) /\ Gtp) ;
		constraint weighted <-> (not(unweighted) /\ Weight) ;
		constraint unweighted <-> (not(weighted) /\ Weight) ;
		constraint BFS <-> (not(DFS) /\ Search) ;
		constraint DFS <-> (not(BFS) /\ Search) ;
		constraint Algorithms <-> ( connected \/ stronglyc \/ cycle \/ mstprim \/ mstkruskal \/ shortest ) ;
		constraint mstprim -> unweighted ;
		constraint not (stronglyc /\ shortest);
		constraint (undirected \/ not(mstprim));
		constraint (directed \/ not(shortest));
		constraint (not(mstprim) \/ not(mstkruskal));
		constraint (unweighted \/ not(mstkruskal));
		constraint (undirected \/ not(stronglyc));
		constraint (not(connected) \/ not(stronglyc));
		constraint (Search \/ not(connected));
		constraint (undirected \/ not(mstkruskal));
		constraint (not(mstkruskal) \/ not(shortest));
		constraint (DFS \/ not(cycle));
		constraint (not(mstprim) \/ not(shortest));
		% The solving parameters from the parameters files
		'''
		//Obtained code

		
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}

	
	@Test
	def void gplBasicIntegerParser() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model GPL
		elements:  
			boolean GPL 
			boolean Gtp 
			boolean directed
			boolean undirected
			boolean Weight
			boolean weighted
			boolean unweighted
			boolean Search
			boolean BFS
			boolean DFS
			boolean Algorithms
			boolean connected
			boolean stronglyc
			boolean cycle
			boolean mstprim
			boolean mstkruskal
			boolean shortest
		relations:
			R1: common(GPL)
			R2: decomposition(GPL,[Weight, Search], [0,1])
			R3: decomposition(GPL, [Gtp, Algorithms], [1,1])
			R3X: group(Gtp, [directed, undirected], [1,1])
			R4: group(Weight, [weighted, unweighted], [1,1])
			R5: group(Search, [BFS, DFS], [1,1])
			R6: group(Algorithms, [connected, stronglyc, cycle, mstprim, mstkruskal, shortest], [1,*])
			R7: implies(mstprim, unweighted)
			R8: mutex(stronglyc, shortest)
			R9: expression(undirected OR ~mstprim)
			R10: expression(directed OR ~shortest)
			R11: expression( ~mstprim OR ~mstkruskal )
		 	R12: expression( unweighted OR ~mstkruskal )
		 	R13: expression( undirected OR ~stronglyc )
		 	R14: expression( ~connected OR ~stronglyc )
		 	R15: expression( Search OR ~connected )
		 	R16: expression( undirected OR ~mstkruskal )
		 	R17: expression( ~mstkruskal OR ~shortest )
		 	R18: expression( DFS OR ~cycle )
		 	R19: expression( ~mstprim OR ~shortest)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var 0..1: GPL;
		var 0..1: Gtp;
		var 0..1: directed;
		var 0..1: undirected;
		var 0..1: Weight;
		var 0..1: weighted;
		var 0..1: unweighted;
		var 0..1: Search;
		var 0..1: BFS;
		var 0..1: DFS;
		var 0..1: Algorithms;
		var 0..1: connected;
		var 0..1: stronglyc;
		var 0..1: cycle;
		var 0..1: mstprim;
		var 0..1: mstkruskal;
		var 0..1: shortest;
		% Variables and constraints from the variability relations definition
		constraint GPL == 1;
		constraint GPL >= Weight;
		constraint GPL >= Search;
		constraint GPL == Gtp;
		constraint GPL == Algorithms;
		constraint Gtp <= directed + undirected ;
		constraint directed + undirected  <= Gtp;
		constraint Weight <= weighted + unweighted ;
		constraint weighted + unweighted  <= Weight;
		constraint Search <= BFS + DFS ;
		constraint BFS + DFS  <= Search;
		constraint Algorithms <= connected + stronglyc + cycle + mstprim + mstkruskal + shortest ;
		constraint connected + stronglyc + cycle + mstprim + mstkruskal + shortest  <= 6 * Algorithms;
		constraint mstprim <= unweighted;
		constraint stronglyc + shortest <= 1 ;
		constraint (undirected > 0 \/ not(mstprim > 0));
		constraint (directed > 0 \/ not(shortest > 0));
		constraint (not(mstprim > 0) \/ not(mstkruskal > 0));
		constraint (unweighted > 0 \/ not(mstkruskal > 0));
		constraint (undirected > 0 \/ not(stronglyc > 0));
		constraint (not(connected > 0) \/ not(stronglyc > 0));
		constraint (Search > 0 \/ not(connected > 0));
		constraint (undirected > 0 \/ not(mstkruskal > 0));
		constraint (not(mstkruskal > 0) \/ not(shortest > 0));
		constraint (DFS > 0 \/ not(cycle > 0));
		constraint (not(mstprim > 0) \/ not(shortest > 0));
		% The solving parameters from the parameters files
		'''
		//Obtained code
		val parser= ParserFactory.getParser(Dialect.BASIC_INT, model.name);
		val actual= parser.parseModel(model)
		
		println(actual)
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
	
		@Test
	def void OVMModelMODEVAR() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model RFW
		elements:
			symbolic VP1 
			variants: ['medium-class car', 'upper-class car', 'small truck', 'big truck'] 
			comment:{"Type of vehicle"}
			symbolic VP2 
			variants: ['switchable', 'durable'] 
			comment:{"Activation"}
			boolean  VP3 comment:{"Comfort functions"}
			boolean  v7 comment:{"Non stopping warning"}
			boolean  v8 comment:{"Overspeed warning"}
			boolean  VP4 comment:{"Other signs"}
			boolean  v41 comment:{"Road w/right of way start"}
			boolean  v42 comment:{"city limit"}
			boolean  VP5 comment:{"Prohibition signs"}
			boolean  V51 comment:{"No vehicles"}
			boolean  V52 comment:{"No cars"}
		relations:
			r1: common(VP1, VP2, VP3)
			d1: decomposition(VP5, [V51, V52], [0,1])
			d2: decomposition(VP4, [v41, v42], [0,1])
			d3: decomposition(VP3, [v7, v8], [0,1])
			exp1: expression(VP1 ='big truck' => VP2 ='durable')
			imp1: implies((VP1 ='medium-class car'), [V51,V52])
			imp2: implies(v8, v42)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		% Mapping  variants to integers
		var {1 , 2 , 3 , 4 }  : VP1;
		% Map: medium-class car -> 1,  upper-class car -> 2,  small truck -> 3,  big truck -> 4,  
		% Mapping  variants to integers
		var {1 , 2 }  : VP2;
		% Map: switchable -> 1,  durable -> 2,  
		var 0..1: VP3;
		var 0..1: v7;
		var 0..1: v8;
		var 0..1: VP4;
		var 0..1: v41;
		var 0..1: v42;
		var 0..1: VP5;
		var 0..1: V51;
		var 0..1: V52;
		% Variables and constraints from the variability relations definition
		constraint VP1 == 1;
		constraint VP2 == 1;
		constraint VP3 == 1;
		constraint VP5 >= V51;
		constraint VP5 >= V52;
		constraint VP4 >= v41;
		constraint VP4 >= v42;
		constraint VP3 >= v7;
		constraint VP3 >= v8;
		constraint ((VP1 == 4)  -> (VP2 == 2));
		constraint (VP1 == 1) -> V51;
		constraint (VP1 == 1) -> V52;
		constraint v8 <= v42;
		% The solving parameters from the parameters files
		'''
		//Obtained code
	
		var HlvlGenerator gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.ATTRIBUTE, gen.findDialect(model))
		
		val parser= ParserFactory.getParser(gen.findDialect(model), model.name);
		val actual= parser.parseModel(model)
		
		println(actual)
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
	
	@Test
	def void doplerMODEVAR(){
		
		val hlvlProgram=
		'''
		model Dopler
		elements:
			symbolic scope variants: ['assemble yourself', 'complete suite']
							comment: {"What to buy?"}
			boolean glossary comment:{"Include glossary?"}
			symbolic resolution variants:['800x600', '']
								comment:{"Default resolution?"}
			integer width comment:{"Width?"}
			boolean tools
			boolean configurationWizard
			boolean decisionKing
			boolean projectKing
		relations:
		    c1: common(tools)
		
			g1: group(tools, [configurationWizard, decisionKing, projectKing], [1,3])
			val1: expression(width >= 800 AND width <= 1680)
			e1: expression(resolution='800x600' => width = 800)   
			vis1: visibility(configurationWizard=true, [resolution])
			vis2: visibility(entailed(scope), [glossary])
			vis3: visibility(scope='assemble yourself', [glossary])
		'''
		
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		
		% Map: switchable -> 1,  durable -> 2,  

		% Variables and constraints from the variability relations definition

		% The solving parameters from the parameters files
		'''
		
		//Initializing generator
		var HlvlGenerator gen = new HlvlGenerator
		gen.findDialect(model)
		
		//For testing that the dialect is identified
		Assert.assertEquals(Dialect.ATTRIBUTE, gen.findDialect(model))
		
		// To test the parser
		val parser= ParserFactory.getParser(gen.findDialect(model), model.name);
		val actual= parser.parseModel(model)
		
		println(actual)
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
		
	}
	
	@Test
	def void fmMODEVAR(){
		
		val hlvlProgram=
		'''
		model eShop 
		elements: 
		  boolean connectionType
		  boolean secureConnection 
		  boolean insecureConnection 
		  boolean payment 
		  boolean payPal 
		  symbolic customerType variants: [ 'sporadic' , 'regular' ] 
		  comment: { "This element represents the customer type" } 
		  att integer confidentiality variants: 1 .. 5 
		  att integer confBounded is 2 
		  boolean customerProfile 
		  boolean SMS 
		  boolean card 
		  boolean creditCard 
		  boolean giftCard boolean debitCard 
		  boolean implementation 
		  boolean appServer 
		  boolean machines 
		  att integer certificateType variants: 1 .. 5 
		  symbolic productType variants: [ 'services' , 'products' ] 
		  relations: 
		  com1 : common ( customerType , payment ) 
		  //constraint expressions
		  exp1 : expression ( 3 <= card . confidentiality AND card . confidentiality <= 5 ) 
		  //mutex
		  m1 : mutex (creditCard , insecureConnection) 
		  m2 : mutex ((customerType = 'sporadic') ,[giftCard , creditCard]) 
		  //implications 
		  imp1 : implies (payPal , secureConnection) 
		  imp2 : implies ((customerType = 'regular'), [secureConnection, customerProfile])
		  //decompositions
		  dc1 : decomposition (card, [giftCard ,debitCard] ,[0 , 1]) 
		  dc2 : decomposition (card, [creditCard] ,[1 , 1]) 
		  dc3 : decomposition (implementation ,[appServer] ,[1 , 5]) 
		  dc4 : decomposition (implementation ,[machines] ,[2 , 10]) 
		  att1 : decomposition (payPal , [confidentiality ,certificateType] ,[ 1 , 1]) 
		  att3 : decomposition (card , [confidentiality ,certificateType] ,[ 1 , 1 ]) 
		  //groups
		  g1 : group (payment ,[payPal ,card] ,[1 ,*]) 
		  //visibility
		  v1 : visibility (productType = 'services' ,[implementation ,appServer ,machines])
		  '''
	
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
				% Author: avillota
				% Variables from elements definitions 
				
				% Map: switchable -> 1,  durable -> 2,  
		
				% Variables and constraints from the variability relations definition
		
				% The solving parameters from the parameters files
		'''
		
		//Initializing generator
		var HlvlGenerator gen = new HlvlGenerator
		gen.findDialect(model)
		
		//For testing that the dialect is identified
		Assert.assertEquals(Dialect.MULTIPLICITY, gen.findDialect(model))
		
		// To test the parser
		val parser= ParserFactory.getParser(gen.findDialect(model), model.name);
		val actual= parser.parseModel(model)
		
		println(actual)
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
/**********************************************************************************************************
* Auxiliar methods for testing
*/

	/**to print the parsing errors */
	def void printErrors(Model model){
		if (!model.eResource.errors.isEmpty){
			for (element : model.eResource.errors) {
				println( element.message)
			}
		}
		
	}
	
}