package com.coffee.generator;


import java.util.HashMap
import java.util.Map

import com.coffee.hlvl.ElmDeclaration
import com.coffee.hlvl.Relation
import com.coffee.hlvl.Model
import com.coffee.hlvl.ConstantDecl
import com.coffee.hlvl.Decomposition
import com.coffee.hlvl.VariableDecl
import com.coffee.hlvl.Group
import com.coffee.hlvl.VarList
//import com.coffee.hlvl.hLVL.MultInstantiation
//import com.coffee.hlvl.hLVL.QImplies
import com.coffee.hlvl.Pair
//import com.coffee.hlvl.hLVL.ComplexImplies
import com.coffee.hlvl.Common
import com.coffee.hlvl.Constraint

/**
 * Abstract Generator, this is the class that process the model and traverses the 
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version HLVL 1
 * August 2018
 * adpated to the HLVl grammar on January 2019
 * updated on july 2019 to include the attributes declaration in the attributesParser
 */
 abstract class AbstractHLVLParser implements IHLVLParser{
	/**
	 * Name of the PL model 
	 */
	private String modelName
	

	private Dialect dialect
	/**
	 * object to obtain the program sentences regarding the type of the problem
	 */
	private TransformationRules rules;
	
	/**
	 * Map with the parent of each variable, for decomposition relations
	 */
	private Map <String, ElmDeclaration> parents;
	
		/**
	 * Map with the parent of each element, for decomposition relations
	 */
	private Map <String, Relation> relations;
	
	
	private StringBuilder operations;
	/**
	 * Constructor method 
	 * @param the name of the model
	 * @param type of the problem
	 */
	new(String name, Dialect dialect) {
		modelName= name
		this.dialect= dialect
		//initializing the data sctucture with the map of parents
		parents= new HashMap<String,ElmDeclaration>();
		relations= new HashMap<String, Relation>();
		operations= new StringBuilder();
	}

	
	/*===================================================================
	 *===================================================================
	  Methods that should be implemented in an instance of the generator (BooleanGenerator, IntegerGenerator)
	  */
	
	/**
	 * Method to obtain a sequence of characters containing the constraint
	 * representation of the model regarding the type of the problem and the
	 * notation.
	 * @param model is an ECORE syntax tree with the program
	 */
	 override parseModel(Model model){
	 	'''
	 	% Autogenerated code form the Coffee framework
	 	% Author: avillota
	 	% Variables from elements definitions 
	 	«parseElements(model)»
	 	% Variables and constraints from the variability relations definition
	 	«parseRelations(model)»
	 	% The solving parameters from the parameters files
	 	«parseOperations(model)»
	 	'''
	 } 
	
	
	
	/*===================================================================
	 *===================================================================
	 * Implemented Methods 
	 */
		
	/**
	 * This method traverses the collection of elements to produce a block of code containing the 
	 * declaration of the elements represented as variables in the minizinc language
	 *  The code for translating an element declaration and relation is produced by an object called rule containing the
	 * transformation rules.  
	 * @param model
	 */
	override parseElements(Model model) {
		var StringBuilder builder = new StringBuilder();

		for (element : model.elements) {
				if (element.declaration instanceof ConstantDecl) {
					val value = (element.declaration as ConstantDecl).value
					// una declaracion boolean sin dominio es considerada ConstantDecl
					if (element.dataType == "boolean" && value === null) { // && (value as BoolVal).value===null){
						builder.append(rules.getElement(element))
					} else {
						builder.append(rules.getConstant(element))
					}
				} else if (element.declaration instanceof VariableDecl) {
					builder.append(rules.getElement(element))
				}
		}
		builder.toString()
	}
	/**
	 * Method to traverse the collection of variability relations and call the 
	 * method that parses each relation individually
	 * @param model 
	 */	
	def parseRelations(Model model) {
		var StringBuilder builder= new StringBuilder();
		for(e: model.relations){
			relations.put(e.name, e.exp)
			builder.append(parseRelation(e.exp))
		}
		builder.toString();
	}
	

	
	/**
	 * This method parses a variability relation individually.
	 * First, the type of variability relation is determined, then a call to the transfromationRules object
	 * is performed to transform each variability relation into a set of constraints considering the type of problem.   
	 * @param rel is a variability relation
	 */
	override parseRelation(Relation rel) {
		switch (rel){
			Common: rules.getCore(rel)
			Decomposition: rules.getDecomposition(rel, parents)
			Group: rules.getGroup(rel, parents)
			Pair: {
				val pair= rel as Pair
				if (pair.operator=="implies"){
					rules.getImpliesPair(rel.var1, rel.var2)
				}
				else{
					rules.getMutexPair(rel.var1, rel.var2)
				}
			}
			VarList:{
				val pair= rel as VarList
				if (pair.operator=="implies"){
					rules.getImpliesList(rel)
				}
				else{
					rules.getMutexList(rel)
				}
			}
			Constraint: rules.getExpression(rel.exp)
//			Visibility: {
//				var ArrayList<CharSequence> relations= new ArrayList<CharSequence>();
//				for(r: rel.list.ids){
//					relations.add(parseRelation(r.exp))
//				}
//				rules.getVisibility(rel, relations)
//			}
		}
	}
	
	def parseOperations(Model model) {
		// creating properties file
		operations.append('''
			{
			 "problemType" : "«dialect.toString()»",
		''')
//		var single = ""
//		var notSingle = ""
//		if (!(model.operations === null)) {
//			for (oper : model.operations.op) {
//				switch (oper) {
//					SingleInstruction: {
//						single += "\""+ oper.name + "\"" + ","
//					}
//					ValidConf: {
//						for (valuation : oper.valuations.pairs) {
//							var value = ""
//							switch valuation.value {
//								Number: value = (valuation.value as Number).value + ""
//								BoolVal: value = (valuation.value as BoolVal).value
//								Symbol: value = (valuation.value as Symbol).value
//							}
//							notSingle += '''
//								{
//									"element" : "«valuation.element.name»",
//									"value" : "«value»"
//								},
//							'''
//						}
//					}
//				}
//			}
//			single= single.substring(0, single.length-1)
//		}
//
//		properties += '''
//			"operationSingle" : [«single»],
//			"validConfiguration" :[«notSingle»]
//			}
//		'''
		''' '''
	}
	
	/*===================================================================
	 *===================================================================
	 *  Getters and setters
	 */	
	def getModelName() {
		return modelName
	}
	
	def getDialect() {
		return dialect
	}
	
	def addParents(Decomposition exp) {
		for (element : exp.children.values) {
			parents.put(element.name, exp.parent)
		}
	}
	
	def getParents(){
		return parents
		
	}
	def void setTransformationRules(TransformationRules rules){
		this.rules= rules
	}
	
	def TransformationRules getTransformationRules(){
		return this.rules
	}
	override CharSequence getOperations(long time){
		operations.append(
		''' "parsingTime"  : "«time»ms"
		}'''
		)
		return operations.toString()
	}
	
	
}