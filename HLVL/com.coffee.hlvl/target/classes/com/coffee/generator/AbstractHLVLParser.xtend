package com.coffee.generator;

import java.util.HashMap
import java.util.Map

import com.coffee.hlvl.ElmDeclaration
import com.coffee.hlvl.Relation
import com.coffee.hlvl.Model
import com.coffee.hlvl.ConstantDecl
import com.coffee.hlvl.Decomposition
import com.coffee.hlvl.VariableDecl
import com.coffee.hlvl.Group
import com.coffee.hlvl.VarList
//import com.coffee.hlvl.hLVL.MultInstantiation
//import com.coffee.hlvl.hLVL.QImplies
import com.coffee.hlvl.Pair
//import com.coffee.hlvl.hLVL.ComplexImplies
import com.coffee.hlvl.Common
import com.coffee.hlvl.Constraint

/**
 * Abstract Generator, this is the class that process the model and traverses the 
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version HLVL 1
 * August 2018
 * adpated to the HLVl grammar on January 2019
 * updated on july 2019 to include the attributes declaration in the attributesParser
 */
abstract class AbstractHLVLParser implements IHLVLParser {
	/**
	 * Name of the PL model 
	 */
	private String modelName

	private Dialect dialect
	/**
	 * object to obtain the program sentences regarding the type of the problem
	 */
	private TransformationRules rules;

	/**
	 * Map with the parent of each variable, for decomposition relations
	 */
	private Map<String, ElmDeclaration> parents;

	/**
	 * Map with the parent of each element, for decomposition relations
	 */
	private Map<String, Relation> relations;

	private StringBuilder operations;

	/**
	 * Constructor method 
	 * @param the name of the model
	 * @param type of the problem
	 */
	new(String name, Dialect dialect) {
		modelName = name
		this.dialect = dialect
		// initializing the data sctucture with the map of parents
		parents = new HashMap<String, ElmDeclaration>();
		relations = new HashMap<String, Relation>();
		operations = new StringBuilder();
	}

	/*===================================================================
	 * ===================================================================
	 *   Methods that should be implemented in an instance of the generator (BooleanGenerator, IntegerGenerator)
	 */
	/**
	 * Method to obtain a sequence of characters containing the constraint
	 * representation of the model regarding the type of the problem and the
	 * notation.
	 * @param model is an ECORE syntax tree with the program
	 */
	override parseModel(Model model) {
		'''
			% Autogenerated code form the Coffee framework
			% Author: avillota
			% Variables from elements definitions 
			«parseElements(model)»
			% Variables and constraints from the variability relations definition
			«parseRelations(model)»
			% The solving parameters from the parameters files
			«parseOperations(model)»
		'''
	}

	/*===================================================================
	 * ===================================================================
	 * Implemented Methods 
	 */
	/**
	 * This method traverses the collection of elements to produce a block of code containing the 
	 * declaration of the elements represented as variables in the minizinc language
	 *  The code for translating an element declaration and relation is produced by an object called rule containing the
	 * transformation rules.  
	 * @param model
	 */
	override parseElements(Model model) {
		var StringBuilder builder = new StringBuilder();

		for (element : model.elements) {
			if (element.declaration instanceof ConstantDecl) {
				val value = (element.declaration as ConstantDecl).value
				// una declaracion boolean sin dominio es considerada ConstantDecl
				if (element.dataType == "boolean" && value === null) { // && (value as BoolVal).value===null){
					builder.append(rules.getElement(element))
				} else {
					builder.append(rules.getConstant(element))
				}
			} else if (element.declaration instanceof VariableDecl) {
				builder.append(rules.getElement(element))
			}
		}
		builder.toString()
	}

	/**
	 * Method to traverse the collection of variability relations and call the 
	 * method that parses each relation individually
	 * @param model 
	 */
	def parseRelations(Model model) {
		var StringBuilder builder = new StringBuilder();
		for (e : model.relations) {
			relations.put(e.name, e.exp)
			builder.append(parseRelation(e.exp))
		}
		builder.toString();
	}

	/**
	 * This method parses a variability relation individually.
	 * First, the type of variability relation is determined, then a call to the transfromationRules object
	 * is performed to transform each variability relation into a set of constraints considering the type of problem.   
	 * @param rel is a variability relation
	 */
	override parseRelation(Relation rel) {
		switch (rel) {
			Common:
				rules.getCore(rel)
			Decomposition:
				rules.getDecomposition(rel, parents)
			Group:
				rules.getGroup(rel, parents)
			Pair: {
				val pair = rel as Pair
				if (pair.operator == "implies") {
					rules.getImpliesPair(rel.var1, rel.var2)
				} else {
					rules.getMutexPair(rel.var1, rel.var2)
				}
			}
			VarList: {
				val pair = rel as VarList
				if (pair.operator == "implies") {
					rules.getImpliesList(rel)
				} else {
					rules.getMutexList(rel)
				}
			}
			Constraint:
				rules.getExpression(rel.exp)
//			Visibility: {
//				var ArrayList<CharSequence> relations= new ArrayList<CharSequence>();
//				for(r: rel.list.ids){
//					relations.add(parseRelation(r.exp))
//				}
//				rules.getVisibility(rel, relations)
//			}
		}
	}

	def parseOperations(Model model) {
		// creating properties file
		operations.append('''
			{
			 "problemType" : "«dialect.toString()»",
		''')
//		var single = ""
//		var notSingle = ""
//		if (!(model.operations === null)) {
//			for (oper : model.operations.op) {
//				switch (oper) {
//					SingleInstruction: {
//						single += "\""+ oper.name + "\"" + ","
//					}
//					ValidConf: {
//						for (valuation : oper.valuations.pairs) {
//							var value = ""
//							switch valuation.value {
//								Number: value = (valuation.value as Number).value + ""
//								BoolVal: value = (valuation.value as BoolVal).value
//								Symbol: value = (valuation.value as Symbol).value
//							}
//							notSingle += '''
//								{
//									"element" : "«valuation.element.name»",
//									"value" : "«value»"
//								},
//							'''
//						}
//					}
//				}
//			}
//			single= single.substring(0, single.length-1)
//		}
//
//		properties += '''
//			"operationSingle" : [«single»],
//			"validConfiguration" :[«notSingle»]
//			}
//		'''
		''' '''
	}

	/*===================================================================
	 * ===================================================================
	 *  Getters and setters
	 */
	def getModelName() {
		return modelName
	}

	def getDialect() {
		return dialect
	}

	def addParents(Decomposition exp) {
		for (element : exp.children.values) {
			parents.put(element.name, exp.parent)
		}
	}

	def getParents() {
		return parents

	}

	def void setTransformationRules(TransformationRules rules) {
		this.rules = rules
	}

	def TransformationRules getTransformationRules() {
		return this.rules
	}

	override CharSequence getOperations(long time) {
		operations.append(
			''' "parsingTime"  : "«time»ms"
		}'''
		)
		return operations.toString()
	}

}
